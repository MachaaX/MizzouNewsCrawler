name: Build and Deploy Services

# Automatically build and deploy services when code changes are merged into main
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to build (comma-separated: processor,api,crawler,base,ml-base,migrator, or "all")'
        required: false
        default: 'auto'
        type: string

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      processor: ${{ steps.detect.outputs.processor }}
      api: ${{ steps.detect.outputs.api }}
      crawler: ${{ steps.detect.outputs.crawler }}
      base: ${{ steps.detect.outputs.base }}
      ml_base: ${{ steps.detect.outputs.ml_base }}
      migrator: ${{ steps.detect.outputs.migrator }}
      any_changed: ${{ steps.detect.outputs.any_changed }}
      services_to_build: ${{ steps.services.outputs.list }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history to compare with previous commits

      - name: Detect changed files
        id: detect
        run: |
          # Capture commit range for logging
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.event.after }}"
          
          echo "üîç Change Detection Starting..."
          echo "Event: ${{ github.event_name }}"
          echo "Before: $BEFORE"
          echo "After: $AFTER"
          echo ""
          
          # Get list of changed files since last commit (for push) or since workflow dispatch (manual override)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual dispatch - use provided input or default to auto
            SERVICES_INPUT="${{ github.event.inputs.services }}"
            if [ "$SERVICES_INPUT" != "auto" ]; then
              echo "‚úÖ Using manually specified services: $SERVICES_INPUT"
              # Parse comma-separated list
              for service in $(echo "$SERVICES_INPUT" | tr ',' ' '); do
                service=$(echo "$service" | xargs)  # trim whitespace
                echo "${service}=true" >> $GITHUB_OUTPUT
              done
              echo "any_changed=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Get the commit range for change detection
          # Use multiple methods to ensure we catch all changes (works with squash merges, regular commits, etc.)
          CHANGED_FILES=""
          
          if [ "${{ github.event_name }}" == "push" ]; then
            # For push events, try multiple methods to detect changes
            if [ "$BEFORE" == "0000000000000000000000000000000000000000" ]; then
              # Initial push - check all files
              echo "üìù Initial push detected - checking all files"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD)
            else
              # Method 1: Standard diff-tree (works for regular commits)
              METHOD1=$(git diff-tree --no-commit-id --name-only -r $BEFORE $AFTER 2>/dev/null || true)
              
              # Method 2: Direct diff (works for squash merges and edge cases)
              METHOD2=$(git diff --name-only $BEFORE...$AFTER 2>/dev/null || true)
              
              # Combine results (remove duplicates)
              CHANGED_FILES=$(printf "%s\n%s" "$METHOD1" "$METHOD2" | grep -v '^$' | sort -u)
              
              # If both methods failed, compare with previous commit
              if [ -z "$CHANGED_FILES" ]; then
                echo "‚ö†Ô∏è  Primary methods failed, using HEAD~1 fallback"
                CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
              fi
            fi
          else
            # Fallback: compare HEAD with HEAD~1
            echo "üìù Non-push event - comparing HEAD~1 with HEAD"
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
          fi

          echo "üìã Changed files detected:"
          if [ -n "$CHANGED_FILES" ]; then
            echo "$CHANGED_FILES" | wc -l | xargs echo "Total:"
            echo "$CHANGED_FILES" | sed 's/^/  /'
          else
            echo "  (none detected)"
          fi
          echo ""

          # Initialize all services as false
          echo "processor=false" >> $GITHUB_OUTPUT
          echo "api=false" >> $GITHUB_OUTPUT
          echo "crawler=false" >> $GITHUB_OUTPUT
          echo "base=false" >> $GITHUB_OUTPUT
          echo "ml_base=false" >> $GITHUB_OUTPUT
          echo "migrator=false" >> $GITHUB_OUTPUT
          echo "any_changed=false" >> $GITHUB_OUTPUT

          # Analyze changes and set flags
          # Base image: only rebuild for OS/dependency changes, NOT for migrations
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.base|Dockerfile\.ci-base|requirements-base\.txt|requirements-dev\.txt'; then
            echo "base=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Base image needs rebuild (Dockerfile.base, requirements-base.txt)"
          fi

          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.ml-base|requirements-ml\.txt'; then
            echo "ml_base=true" >> $GITHUB_OUTPUT
            echo "‚úÖ ML base image needs rebuild (Dockerfile.ml-base, requirements-ml.txt)"
          fi

          # Processor: rebuild for code changes or database migrations
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.processor|requirements-processor\.txt|src/|pyproject\.toml|alembic/'; then
            echo "processor=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Processor needs rebuild (code/migrations: Dockerfile.processor, src/, alembic/)"
          fi

          # API: rebuild for code, dependencies, or database migrations
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.api|requirements-api\.txt|src/|pyproject\.toml|backend/|alembic/'; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "‚úÖ API needs rebuild (code/migrations: Dockerfile.api, src/, backend/, alembic/)"
          fi

          # Crawler: rebuild for code or dependency changes
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.crawler|requirements-crawler\.txt|src/|pyproject\.toml'; then
            echo "crawler=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Crawler needs rebuild (Dockerfile.crawler, src/)"
          fi

          # Migrator: rebuild for migrations or requirements
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.migrator|requirements-migrator\.txt|alembic/'; then
            echo "migrator=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Migrator needs rebuild (alembic migrations or requirements)"
          fi

          # Check if anything changed
          if [ -n "$CHANGED_FILES" ]; then
            echo "any_changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine services to build
        id: services
        run: |
          SERVICES=""
          
          [ "${{ steps.detect.outputs.base }}" == "true" ] && SERVICES="${SERVICES}base "
          [ "${{ steps.detect.outputs.ml_base }}" == "true" ] && SERVICES="${SERVICES}ml-base "
          [ "${{ steps.detect.outputs.processor }}" == "true" ] && SERVICES="${SERVICES}processor "
          [ "${{ steps.detect.outputs.api }}" == "true" ] && SERVICES="${SERVICES}api "
          [ "${{ steps.detect.outputs.crawler }}" == "true" ] && SERVICES="${SERVICES}crawler "
          [ "${{ steps.detect.outputs.migrator }}" == "true" ] && SERVICES="${SERVICES}migrator "

          if [ -z "$SERVICES" ]; then
            echo "list=none" >> $GITHUB_OUTPUT
          else
            # Remove trailing space and convert to comma-separated list
            SERVICES=$(echo "$SERVICES" | xargs | sed 's/ /,/g')
            echo "list=$SERVICES" >> $GITHUB_OUTPUT
          fi

      - name: Log detected changes
        run: |
          echo "=== Service Build Detection ==="
          echo "Event: ${{ github.event_name }}"
          echo "Base image rebuild: ${{ steps.detect.outputs.base }}"
          echo "ML base image rebuild: ${{ steps.detect.outputs.ml_base }}"
          echo "Processor rebuild: ${{ steps.detect.outputs.processor }}"
          echo "API rebuild: ${{ steps.detect.outputs.api }}"
          echo "Crawler rebuild: ${{ steps.detect.outputs.crawler }}"
          echo "Migrator rebuild: ${{ steps.detect.outputs.migrator }}"
          echo "Services to build: ${{ steps.services.outputs.list }}"
          echo "================================"

  build-base:
    name: Build Base Image
    needs: detect-changes
    runs-on: ubuntu-latest

    steps:
      - name: Skip base build (not requested)
        if: needs.detect-changes.outputs.base != 'true'
        run: 'echo "Info: Base image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.base == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.base == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.base == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.base == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-base-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger base image build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ Base image build triggered (build ID: $BUILD_ID)"

  build-ml-base:
    name: Build ML Base Image
    needs: [detect-changes, build-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip ml-base build (not requested)
        if: needs.detect-changes.outputs.ml_base != 'true'
        run: 'echo "Info: ML base image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.ml_base == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.ml_base == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.ml_base == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.ml_base == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-ml-base-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger ml-base image build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ ML base image build triggered (build ID: $BUILD_ID)"

  build-processor:
    name: Build Processor
    needs: [detect-changes, build-ml-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip processor build (not requested)
        if: needs.detect-changes.outputs.processor != 'true'
        run: 'echo "Info: Processor image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.processor == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.processor == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.processor == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.processor == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-processor-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger processor build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ Processor build triggered (build ID: $BUILD_ID)"

  build-api:
    name: Build API
    needs: [detect-changes, build-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip API build (not requested)
        if: needs.detect-changes.outputs.api != 'true'
        run: 'echo "Info: API image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.api == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.api == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.api == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.api == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-api-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger API build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ API build triggered (build ID: $BUILD_ID)"

  build-crawler:
    name: Build Crawler
    needs: [detect-changes, build-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip crawler build (not requested)
        if: needs.detect-changes.outputs.crawler != 'true'
        run: 'echo "Info: Crawler image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.crawler == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.crawler == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.crawler == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.crawler == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-crawler-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger crawler build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ Crawler build triggered (build ID: $BUILD_ID)"

  build-migrator:
    name: Build Migrator
    needs: [detect-changes, build-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip migrator build (not requested)
        if: needs.detect-changes.outputs.migrator != 'true'
        run: 'echo "Info: Migrator image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.migrator == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.migrator == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.migrator == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.migrator == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-migrator-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "‚ùå Failed to trigger migrator build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "‚úÖ Migrator build triggered (build ID: $BUILD_ID)"

  wait-for-builds:
    name: Wait for Cloud Builds
    needs: [detect-changes, build-base, build-ml-base, build-processor, build-api, build-crawler, build-migrator]
    if: needs.detect-changes.outputs.any_changed == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Wait for builds to complete
        run: |
          echo "‚è≥ Waiting for Cloud Build jobs to complete..."
          echo ""
          
          # Store build IDs from submitted jobs
          SERVICES="${{ needs.detect-changes.outputs.services_to_build }}"
          
          if [ "$SERVICES" == "none" ]; then
            echo "‚ÑπÔ∏è  No service rebuilds - skipping build wait"
            exit 0
          fi
          
          # Get the 10 most recent builds in the last 10 minutes
          # Filter by status != SUCCESS to find in-progress builds
          gcloud builds list \
            --project=$GCP_PROJECT \
            --limit=50 \
            --filter="createTime>'-10m' AND (status=QUEUED OR status=WORKING)" \
            --format="value(id,status,startTime)" > /tmp/builds.txt
          
          if [ ! -s /tmp/builds.txt ]; then
            echo "‚ÑπÔ∏è  No in-progress builds found"
            exit 0
          fi
          
          BUILD_IDS=$(awk '{print $1}' /tmp/builds.txt)
          TOTAL_BUILDS=$(echo "$BUILD_IDS" | wc -l)
          echo "Found $TOTAL_BUILDS build(s) in progress"
          echo ""
          
          # Poll builds until completion
          MAX_WAIT=3600  # 60 minutes timeout
          ELAPSED=0
          POLL_INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STILL_RUNNING=0
            
            for BUILD_ID in $BUILD_IDS; do
              STATUS=$(gcloud builds describe "$BUILD_ID" \
                --project=$GCP_PROJECT \
                --format='value(status)')
              
              case $STATUS in
                QUEUED|WORKING)
                  echo "‚è≥ Build $BUILD_ID still running (status: $STATUS)"
                  ((STILL_RUNNING++))
                  ;;
                SUCCESS)
                  echo "‚úÖ Build $BUILD_ID completed successfully"
                  ;;
                FAILURE)
                  echo "‚ùå Build $BUILD_ID failed"
                  exit 1
                  ;;
                TIMEOUT)
                  echo "‚è±Ô∏è  Build $BUILD_ID timed out"
                  exit 1
                  ;;
                *)
                  echo "‚ö†Ô∏è  Build $BUILD_ID status: $STATUS"
                  ;;
              esac
            done
            
            if [ $STILL_RUNNING -eq 0 ]; then
              echo ""
              echo "‚úÖ All builds completed!"
              exit 0
            fi
            
            echo "  Waiting $POLL_INTERVAL seconds before next check... ($ELAPSED/$MAX_WAIT seconds elapsed)"
            sleep $POLL_INTERVAL
            ((ELAPSED += POLL_INTERVAL))
          done
          
          echo "‚ùå Timeout waiting for builds (exceeded ${MAX_WAIT}s)"
          exit 1

  build-summary:
    name: Build Summary
    needs: [detect-changes, wait-for-builds]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Report build status
        run: |
          echo "=== Build and Deploy Summary ==="
          echo "Services targeted: ${{ needs.detect-changes.outputs.services_to_build }}"
          
          if [ "${{ needs.detect-changes.outputs.services_to_build }}" == "none" ]; then
            echo "‚ÑπÔ∏è  No service rebuilds detected (documentation/config-only changes)"
          else
            BUILD_RESULT="${{ needs.wait-for-builds.result }}"
            if [ "$BUILD_RESULT" == "success" ] || [ "$BUILD_RESULT" == "skipped" ]; then
              echo "‚úÖ All Cloud Build jobs completed successfully"
              echo "üöÄ Services are ready for deployment to production"
            else
              echo "‚ùå Build wait job failed (result: $BUILD_RESULT)"
              exit 1
            fi
          fi

  deploy:
    name: Deploy to Production
    needs: [detect-changes, wait-for-builds]
    if: needs.wait-for-builds.result == 'success' && needs.detect-changes.outputs.any_changed == 'true'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Get GKE Credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: mizzou-cluster
          location: us-central1-a

      - name: Install envsubst
        run: sudo apt-get update && sudo apt-get install -y gettext-base

      - name: Update versions and deploy
        env:
          PROCESSOR_CHANGED: ${{ needs.detect-changes.outputs.processor }}
          API_CHANGED: ${{ needs.detect-changes.outputs.api }}
          CRAWLER_CHANGED: ${{ needs.detect-changes.outputs.crawler }}
          COMMIT_SHA: ${{ github.sha }}
        run: |
          # Make scripts executable
          chmod +x scripts/apply-manifests.sh
          
          VERSIONS_FILE="k8s/versions.env"
          
          update_version() {
              local var_name=$1
              local new_val=$2
              local file=$3
              sed -i "s/export $var_name=.*/export $var_name=$new_val/" "$file"
          }
          
          echo "üìù Updating versions in $VERSIONS_FILE..."
          
          if [ "$PROCESSOR_CHANGED" == "true" ]; then
              update_version "PROCESSOR_TAG" "$COMMIT_SHA" "$VERSIONS_FILE"
              echo "   Updated PROCESSOR_TAG to $COMMIT_SHA"
          fi
          
          if [ "$CRAWLER_CHANGED" == "true" ]; then
              update_version "CRAWLER_TAG" "$COMMIT_SHA" "$VERSIONS_FILE"
              echo "   Updated CRAWLER_TAG to $COMMIT_SHA"
          fi
          
          if [ "$API_CHANGED" == "true" ]; then
              update_version "API_TAG" "$COMMIT_SHA" "$VERSIONS_FILE"
              echo "   Updated API_TAG to $COMMIT_SHA"
          fi
          
          echo "üöÄ Applying manifests..."
          ./scripts/apply-manifests.sh
