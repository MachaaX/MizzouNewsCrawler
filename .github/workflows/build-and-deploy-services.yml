name: Build and Deploy Services

# Automatically build and deploy services when code changes are merged into main
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      services:
        description: 'Services to build (comma-separated: processor,api,crawler,base,ml-base, or "all")'
        required: false
        default: 'auto'
        type: string

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      processor: ${{ steps.detect.outputs.processor }}
      api: ${{ steps.detect.outputs.api }}
      crawler: ${{ steps.detect.outputs.crawler }}
      base: ${{ steps.detect.outputs.base }}
      ml_base: ${{ steps.detect.outputs.ml_base }}
      any_changed: ${{ steps.detect.outputs.any_changed }}
      services_to_build: ${{ steps.services.outputs.list }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history to compare with previous commits

      - name: Detect changed files
        id: detect
        run: |
          # Capture commit range for logging
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.event.after }}"
          
          echo "ðŸ” Change Detection Starting..."
          echo "Event: ${{ github.event_name }}"
          echo "Before: $BEFORE"
          echo "After: $AFTER"
          echo ""
          
          # Get list of changed files since last commit (for push) or since workflow dispatch (manual override)
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual dispatch - use provided input or default to auto
            SERVICES_INPUT="${{ github.event.inputs.services }}"
            if [ "$SERVICES_INPUT" != "auto" ]; then
              echo "âœ… Using manually specified services: $SERVICES_INPUT"
              # Parse comma-separated list
              for service in $(echo "$SERVICES_INPUT" | tr ',' ' '); do
                service=$(echo "$service" | xargs)  # trim whitespace
                echo "${service}=true" >> $GITHUB_OUTPUT
              done
              echo "any_changed=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # Get the commit range for change detection
          # Use multiple methods to ensure we catch all changes (works with squash merges, regular commits, etc.)
          CHANGED_FILES=""
          
          if [ "${{ github.event_name }}" == "push" ]; then
            # For push events, try multiple methods to detect changes
            if [ "$BEFORE" == "0000000000000000000000000000000000000000" ]; then
              # Initial push - check all files
              echo "ðŸ“ Initial push detected - checking all files"
              CHANGED_FILES=$(git ls-tree -r --name-only HEAD)
            else
              # Method 1: Standard diff-tree (works for regular commits)
              METHOD1=$(git diff-tree --no-commit-id --name-only -r $BEFORE $AFTER 2>/dev/null || true)
              
              # Method 2: Direct diff (works for squash merges and edge cases)
              METHOD2=$(git diff --name-only $BEFORE...$AFTER 2>/dev/null || true)
              
              # Combine results (remove duplicates)
              CHANGED_FILES=$(printf "%s\n%s" "$METHOD1" "$METHOD2" | grep -v '^$' | sort -u)
              
              # If both methods failed, compare with previous commit
              if [ -z "$CHANGED_FILES" ]; then
                echo "âš ï¸  Primary methods failed, using HEAD~1 fallback"
                CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
              fi
            fi
          else
            # Fallback: compare HEAD with HEAD~1
            echo "ðŸ“ Non-push event - comparing HEAD~1 with HEAD"
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
          fi

          echo "ðŸ“‹ Changed files detected:"
          if [ -n "$CHANGED_FILES" ]; then
            echo "$CHANGED_FILES" | wc -l | xargs echo "Total:"
            echo "$CHANGED_FILES" | sed 's/^/  /'
          else
            echo "  (none detected)"
          fi
          echo ""

          # Initialize all services as false
          echo "processor=false" >> $GITHUB_OUTPUT
          echo "api=false" >> $GITHUB_OUTPUT
          echo "crawler=false" >> $GITHUB_OUTPUT
          echo "base=false" >> $GITHUB_OUTPUT
          echo "ml_base=false" >> $GITHUB_OUTPUT
          echo "any_changed=false" >> $GITHUB_OUTPUT

          # Analyze changes and set flags with more precise detection
          # Base image: only rebuild for OS/dependency changes
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.base|Dockerfile\.ci-base|requirements-base\.txt|requirements-dev\.txt'; then
            echo "base=true" >> $GITHUB_OUTPUT
            echo "âœ… Base image needs rebuild (Dockerfile.base, requirements-base.txt)"
          fi

          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.ml-base|requirements-ml\.txt'; then
            echo "ml_base=true" >> $GITHUB_OUTPUT
            echo "âœ… ML base image needs rebuild (Dockerfile.ml-base, requirements-ml.txt)"
          fi

          # Processor: rebuild for processor-specific changes, ML code, or migrations
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.processor|requirements-processor\.txt|src/(models|pipeline|utils|services|ml)/|pyproject\.toml|orchestration/|alembic/versions/'; then
            echo "processor=true" >> $GITHUB_OUTPUT
            echo "âœ… Processor needs rebuild (processor-specific code or migrations)"
          fi

          # API: rebuild for API-specific changes, shared models, or migrations
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.api|requirements-api\.txt|src/(models|services)/|backend/|pyproject\.toml|alembic/versions/'; then
            echo "api=true" >> $GITHUB_OUTPUT
            echo "âœ… API needs rebuild (API-specific code or shared models)"
          fi

          # Crawler: rebuild for crawler-specific changes
          if echo "$CHANGED_FILES" | grep -qE 'Dockerfile\.crawler|requirements-crawler\.txt|src/(crawler|models|services|utils)/|pyproject\.toml'; then
            echo "crawler=true" >> $GITHUB_OUTPUT
            echo "âœ… Crawler needs rebuild (crawler-specific code)"
          fi

          # Note: Migrator builds are handled separately and only when actual migration changes occur

          # Check if anything changed
          if [ -n "$CHANGED_FILES" ]; then
            echo "any_changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine services to build
        id: services
        run: |
          SERVICES=""
          
          [ "${{ steps.detect.outputs.base }}" == "true" ] && SERVICES="${SERVICES}base "
          [ "${{ steps.detect.outputs.ml_base }}" == "true" ] && SERVICES="${SERVICES}ml-base "
          [ "${{ steps.detect.outputs.processor }}" == "true" ] && SERVICES="${SERVICES}processor "
          [ "${{ steps.detect.outputs.api }}" == "true" ] && SERVICES="${SERVICES}api "
          [ "${{ steps.detect.outputs.crawler }}" == "true" ] && SERVICES="${SERVICES}crawler "

          if [ -z "$SERVICES" ]; then
            echo "list=none" >> $GITHUB_OUTPUT
          else
            # Remove trailing space and convert to comma-separated list
            SERVICES=$(echo "$SERVICES" | xargs | sed 's/ /,/g')
            echo "list=$SERVICES" >> $GITHUB_OUTPUT
          fi

      - name: Log detected changes
        run: |
          echo "=== Service Build Detection ==="
          echo "Event: ${{ github.event_name }}"
          echo "Base image rebuild: ${{ steps.detect.outputs.base }}"
          echo "ML base image rebuild: ${{ steps.detect.outputs.ml_base }}"
          echo "Processor rebuild: ${{ steps.detect.outputs.processor }}"
          echo "API rebuild: ${{ steps.detect.outputs.api }}"
          echo "Crawler rebuild: ${{ steps.detect.outputs.crawler }}"
          echo "Services to build: ${{ steps.services.outputs.list }}"
          echo "================================"

  build-base:
    name: Build Base Image
    needs: detect-changes
    runs-on: ubuntu-latest

    steps:
      - name: Skip base build (not requested)
        if: needs.detect-changes.outputs.base != 'true'
        run: 'echo "Info: Base image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.base == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.base == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.base == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.base == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-base-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "âŒ Failed to trigger base image build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "âœ… Base image build triggered (build ID: $BUILD_ID)"

  build-ml-base:
    name: Build ML Base Image
    needs: [detect-changes, build-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip ml-base build (not requested)
        if: needs.detect-changes.outputs.ml_base != 'true'
        run: 'echo "Info: ML base image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.ml_base == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.ml_base == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.ml_base == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.ml_base == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-ml-base-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "âŒ Failed to trigger ml-base image build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "âœ… ML base image build triggered (build ID: $BUILD_ID)"

  build-processor:
    name: Build Processor
    needs: [detect-changes, build-ml-base]
    runs-on: ubuntu-latest

    steps:
      - name: Skip processor build (not requested)
        if: needs.detect-changes.outputs.processor != 'true'
        run: 'echo "Info: Processor image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.processor == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.processor == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.processor == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.processor == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-processor-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "âŒ Failed to trigger processor build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "âœ… Processor build triggered (build ID: $BUILD_ID)"

  build-api:
    name: Build API
    needs: [detect-changes, build-processor]
    runs-on: ubuntu-latest

    steps:
      - name: Skip API build (not requested)
        if: needs.detect-changes.outputs.api != 'true'
        run: 'echo "Info: API image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.api == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.api == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.api == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.api == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-api-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "âŒ Failed to trigger API build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "âœ… API build triggered (build ID: $BUILD_ID)"

  build-crawler:
    name: Build Crawler
    needs: [detect-changes, build-api]
    runs-on: ubuntu-latest

    steps:
      - name: Skip crawler build (not requested)
        if: needs.detect-changes.outputs.crawler != 'true'
        run: 'echo "Info: Crawler image not requested; skipping Cloud Build trigger."'

      - uses: actions/checkout@v4
        if: needs.detect-changes.outputs.crawler == 'true'

      - name: Authenticate to Google Cloud
        if: needs.detect-changes.outputs.crawler == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: needs.detect-changes.outputs.crawler == 'true'
        uses: google-github-actions/setup-gcloud@v1

      - name: Trigger Cloud Build
        if: needs.detect-changes.outputs.crawler == 'true'
        run: |
          set +e
          BUILD_ID=$(gcloud builds triggers run build-crawler-manual \
            --branch="${{ github.ref_name }}" \
            --format="value(metadata.build.id)" 2>&1)
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -ne 0 ] || [ -z "$BUILD_ID" ]; then
            echo "âŒ Failed to trigger crawler build"
            echo "$BUILD_ID"
            exit 1
          fi
          echo "âœ… Crawler build triggered (build ID: $BUILD_ID)"

  wait-for-builds:
    name: Wait for Cloud Builds
    needs: [detect-changes, build-base, build-ml-base, build-processor, build-api, build-crawler]
    if: needs.detect-changes.outputs.any_changed == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Wait for builds to complete
        run: |
          echo "â³ Waiting for Cloud Build jobs to complete..."
          echo ""
          
          # Store build IDs from submitted jobs
          SERVICES="${{ needs.detect-changes.outputs.services_to_build }}"
          
          if [ "$SERVICES" == "none" ]; then
            echo "â„¹ï¸  No service rebuilds - skipping build wait"
            exit 0
          fi
          
          # Get the 10 most recent builds in the last 10 minutes
          # Filter by status != SUCCESS to find in-progress builds
          gcloud builds list \
            --project=$GCP_PROJECT \
            --limit=50 \
            --filter="createTime>'-10m' AND (status=QUEUED OR status=WORKING)" \
            --format="value(id,status,startTime)" > /tmp/builds.txt
          
          if [ ! -s /tmp/builds.txt ]; then
            echo "â„¹ï¸  No in-progress builds found"
            exit 0
          fi
          
          BUILD_IDS=$(awk '{print $1}' /tmp/builds.txt)
          TOTAL_BUILDS=$(echo "$BUILD_IDS" | wc -l)
          echo "Found $TOTAL_BUILDS build(s) in progress"
          echo ""
          
          # Poll builds until completion
          MAX_WAIT=3600  # 60 minutes timeout
          ELAPSED=0
          POLL_INTERVAL=30
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STILL_RUNNING=0
            
            for BUILD_ID in $BUILD_IDS; do
              STATUS=$(gcloud builds describe "$BUILD_ID" \
                --project=$GCP_PROJECT \
                --format='value(status)')
              
              case $STATUS in
                QUEUED|WORKING)
                  echo "â³ Build $BUILD_ID still running (status: $STATUS)"
                  ((STILL_RUNNING++))
                  ;;
                SUCCESS)
                  echo "âœ… Build $BUILD_ID completed successfully"
                  ;;
                FAILURE)
                  echo "âŒ Build $BUILD_ID failed"
                  exit 1
                  ;;
                TIMEOUT)
                  echo "â±ï¸  Build $BUILD_ID timed out"
                  exit 1
                  ;;
                *)
                  echo "âš ï¸  Build $BUILD_ID status: $STATUS"
                  ;;
              esac
            done
            
            if [ $STILL_RUNNING -eq 0 ]; then
              echo ""
              echo "âœ… All builds completed!"
              exit 0
            fi
            
            echo "  Waiting $POLL_INTERVAL seconds before next check... ($ELAPSED/$MAX_WAIT seconds elapsed)"
            sleep $POLL_INTERVAL
            ((ELAPSED += POLL_INTERVAL))
          done
          
          echo "âŒ Timeout waiting for builds (exceeded ${MAX_WAIT}s)"
          exit 1

  build-summary:
    name: Build Summary
    needs: [detect-changes, wait-for-builds]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Report build status
        run: |
          echo "=== Build and Deploy Summary ==="
          echo "Services targeted: ${{ needs.detect-changes.outputs.services_to_build }}"
          
          if [ "${{ needs.detect-changes.outputs.services_to_build }}" == "none" ]; then
            echo "â„¹ï¸  No service rebuilds detected (documentation/config-only changes)"
          else
            BUILD_RESULT="${{ needs.wait-for-builds.result }}"
            if [ "$BUILD_RESULT" == "success" ] || [ "$BUILD_RESULT" == "skipped" ]; then
              echo "âœ… All Cloud Build jobs completed successfully"
              echo "ðŸš€ Services deployed automatically via Cloud Build triggers"
              echo "   - Kubernetes deployments updated with new image tags"
              echo "   - Argo WorkflowTemplate updated with new image tags"
            else
              echo "âŒ Build wait job failed (result: $BUILD_RESULT)"
              exit 1
            fi
          fi

  update-versions-env:
    name: Update versions.env
    needs: [detect-changes, wait-for-builds]
    if: >-
      github.ref == 'refs/heads/main' &&
      needs.detect-changes.outputs.services_to_build != 'none' &&
      (needs.wait-for-builds.result == 'success' || needs.wait-for-builds.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare main branch
        run: |
          git checkout main
          git pull --ff-only origin main

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update versions file
        env:
          SHORT_SHA: ${{ github.sha }}
          PROCESSOR_CHANGED: ${{ needs.detect-changes.outputs.processor }}
          API_CHANGED: ${{ needs.detect-changes.outputs.api }}
          CRAWLER_CHANGED: ${{ needs.detect-changes.outputs.crawler }}
        run: |
          SHORT=${SHORT_SHA:0:7}
          ARGS=()
          if [ "$PROCESSOR_CHANGED" = "true" ]; then ARGS+=(--processor "$SHORT"); fi
          if [ "$CRAWLER_CHANGED" = "true" ]; then ARGS+=(--crawler "$SHORT"); fi
          if [ "$API_CHANGED" = "true" ]; then ARGS+=(--api "$SHORT"); fi
          if [ ${#ARGS[@]} -eq 0 ]; then
            echo "No services requested a versions update"
            exit 0
          fi
          ./scripts/update-versions-env.sh "${ARGS[@]}"
          if git diff --quiet k8s/versions.env; then
            echo "versions.env already up to date"
            exit 0
          fi
          git add k8s/versions.env
          git commit -m "chore: update image tags (${SHORT}) [skip ci]"
          git push origin HEAD
